<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<link href="node_modules/remark-bekk/dist/bekk.css" type="text/css" rel="stylesheet">
</head>
<body class="bekk-black">
<textarea id="source">

class: front-page

# Enonic XP Workshop

## Enonic XP 101

Fagdag

Esben Aarseth og Harald Ringvold

06.11.2015

---

class: agenda

# Agenda

* Kjapp gjennomgang av nye konsepter i Enonic XP.
* HANDS-ON: Utvikling av en liten site.

---

# Enonic XP 

* Hva er det?
* Hva er nytt?

???

De eldre versjonene av Enonic er et, om ikke veldig populært, veldig mye brukt CMS hos mange av BEKKs kunder. De har tidligere vært notorisk trege med å legge ut nye releaser, og Enonic XP har nå kommet ut ~5 år etter forrige major versjon som et resultat av det.   

På den positive siden, så har de siden mai i år gitt ut i hvertfall 4 releaser. 

Dere kjenner kanskje til Enonic som et CMS. Enonic har gjort store endringer med Enonic XP. XP er først og fremst en infrastruktur, der de kaller CMS'et for "killer-appen" på toppen av infrastrukturen. I platformen deres ligger CMS-et, mulighet for egenutviklede applikasjoner, Elastic Search, etc. I denne workshopen vil vi hovedsaklig jobbe med cms'et, men dersom dere tidlig finner ut at dere vil se på andre konsepter, så kan dere gjerne gjøre dette.  

Så for hva som er nytt, så er det egentlig det meste. Enonic 4.x har vært ute i ca 5 år nå, og de har innsett at det gamle cms'et bare får være det gamle, og begynne bortimot fra scratch. Noen konsepter henger igjen, slik som innholdstyper og sidemaler. Portletter, datakilder, og alt det andre som har irritert i lengre stund har blitt røsket vekk. 

---
# Enonic XP

Teknologistack: 

* Java og egenutviklet database for innhold i bånn.
* Innhold hentes med javascript, med andre ord er datasources eliminert. Nashorn brukes til å gjøre kall mot java-kode fra javascriptet
* Templating kan utføres med blant annet Thymeleaf, Mustache og Xslt. 
* Bygges med gradle. 

---
# Generell struktur

```html
<!-- print-name.html -->
<h2 data-th-text="${model.name}"></h2>
```

```javascript
// controller.js
module.exports = function(req){
   var model = {name: "Esben Aarseth"};
   var view = resolve('print-name.html');
   return thymeleaf.render(view, model); 
}
```

```xml
<part>
  <display-name>Print name</display-name>
  <config />
</part>
```

---

???

Slik ser generelt mappestrukturen ut i Enonic XP. I utgangspunktet er det 3 filer man trenger, med noen få unntak. Man har en html-fil, en javascript-controller, og en xml-fil som inneholder config for det man utvikler. For content-types og mixins trenger man ikke javascript eller html.

I dette eksempelet her bruker vi thymeleaf (vis til cheatsheet) i HTML'en. Controlleren har ansvar for å hente innhold fra Enonic, og man kaller da thymeleaf.render etter å ha bygget opp en modell og resolvet et view. 

Til slutt har vi konfigurasjonen. I konfigurasjonen kan man stappe på det man trenger for å gi liv til modulen. Dette er bare en eksempel-part, så skal vi vise litt mer nærmere etterhvert.  

# Konsepter

## "Gamle" konsepter, reskinned
* Site
* Content-type

## Nye konsepter
* Page 
* Part
* Layout
* Mixin

---

# Site

```xml
<site>
  <config>
    <field-set name="info">
      <label>Info</label>
      <items>
        <input type="TextLine" name="ga_tracking_code">
          <label>Google Analytics Tracking code</label>
          <occurrences minimum="0" maximum="1"/>
        </input>
        <input type="ContentSelector" name="footer_content">
          <label>Footer links</label>
          <occurrences minimum="0" maximum="10"/>
	  <config>
		<relationship-type>system:reference</relationship-type>
    		<allow-content-type>system:site</allow-content-type>
		<allow-content-type>my-module:article</allow-content-type>
	  </config>
        </input>
      </items>
    </field-set>
  </config>
</site>
```

???
Konseptet rundt sites er vedlikeholdt i Enonic XP. En ting som er litt greit nå er at man kan sette globale konfigurasjoner og variabler på site-nivå, og la redaktører styre dette dersom ønskelig. 

Variabler man setter på site-nivå er gjerne ting man øsnker skal være tilgjengelig for en page, som vi skal komme tilbake til etterhvert. I dette tilfellet har jeg valgt å definere en Tracking kode for Google Analytics, samt lenker som skal gå inn i en global footer.  

En litt urelatert ting som kan være greit å bite seg merke i er at dersom man vil unngå tabell-notasjon i javascript, så må dere unngå bindestreker i name-attributtet på input-felt. Det er name-attributtet man henter ut data fra enonic på.

---
# Content-type

Består av en xml fil: MyContentType.xml
```xml
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<content-type>
  <display-name>My Content Type</display-name>
  <!-- Kan gi innholdstypen et custom navn vha script her -->
  <content-display-name-script></content-display-name-script>
  <super-type>base:structured</super-type>
  <!-- Arv (!) -->
  <is-abstract>false</is-abstract>
  <is-final>true</is-final>
  <is-built-in>false</is-built-in>
  <allow-child-content>true</allow-child-content>
  <form>
    <input type="TextLine" name="etternavn">
      <label>Etternavn</label>
      <occurrences minimum="0" maximum="1"/>
    </input>
  </form>
  <x-data mixin="menu-item"/>
</content-type>
```

???

Content-type: I bunn og grunn de gode gamle content-typene, som ikke lengre er konfigurert på serveren. Det er med andre ord mulig å sjekke inn content-types i koden. Det kan også være nevnt å merke at man har muligheten for arv i content-types, noe som kan være greit for å beholde konsistente navn på felter.


---
# Page

* page.xml
	- Definerer regioner og henter ut hvilket innhold som skal vises i de ulike regionene. 
* controller.js
	- Henter ut det man trenger å outpute i page.html, dersom noe er redaksjonelt styrt. Meta-tagger for eksempel.
* page.html
	- Inneholder skeleton som er felles for alle sider, ala den gamle page.xsl

???

Her kommer skeletonet for siden din. Altså typiske head-tags, en definisjon av regioner som skal være på siden. I stad viste jeg en site.xml hvor man kunne legge til lenker som skal gå i en footer. Disse lenkene kan fores inn i page.html, for å skape en global footer. 

Så kan man gjerne spørre seg selv om man virkelig vil være bundet opp av en global footer som skal være lik alle sites. Dersom dette ikke er ønskelig kan man selvsagt alltids lage en part ut av footeren og plassere denne der det er ønskelig.   

---
# Part

* part.xml
	- Definerer konfigurasjon til en part. Man kan f. eks. ha en part som legger på et bilde. Da vil man gjerne lenke til bildet via denne konfigurasjonen.
* controller.js
	- Henter ut data fra enonic.
* mypart.html
	- Outputter data som er gitt fra controlleren.

???

Fungerer litt på samme måte som det de tidligere kalte portlets, uten datasources. En page består gjerne av en eller flere parts. 

---
# Layout

* layout.xml
	- Definerer gjerne hvor mange regioner man vil ha her.
* controller.js
	- Gjør kall mot innhold her. 
* mylayout.html
	- Rendrer htmlen.
???

Med layouts kan man eksempelvis legge flere parts ved siden av hverandre. Jeg personlig har kun brukt de til dette i hvertfall, men det er nok mulig å gjøre noe mer smart med dem. I en layout legger man som oftest 2 eller flere parts. Dersom du bare trenger en part, trenger man egentlig ikke noen layout. Tanken til enonic bak layouts kan virke inspirert av grid-systemet til Bootstrap 

---

class: middle

# Github

* https://github.com/EsbenAarz/enonic-xp-presentation
* xp.readthedocs.org

</textarea>
<script src="node_modules/remark-bekk/vendor/remark.min.js" type="text/javascript"></script>
<script type="text/javascript">
  var slideshow = remark.create({
    ratio: '16:9',
    highlightStyle: 'monokai'
  });
</script>
</body>
</html>
